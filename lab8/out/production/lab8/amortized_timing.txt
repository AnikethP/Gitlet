Q: Is one GrowList implementation always better than the others?
A:Not always, whenever the geometric doubles, it is less efficient than adding one for that size.

Q: Why is the runtime for N insertions into a geometrically resizing list a Theta(N) operation?
A: When adding up the costs for inserting a sequence N times, the total cost is proportional to N as each addition takes constant time.

Q: Why is the runtime for N insertions into a arithmetically resizing list a Theta(N^2) operation?
A: The resizing cost per item is added each time which causes it to grow to N^2.

Q: How does the runtime per operation for the ArithGrowList compare to that of GeomGrowList and JavaGrowList? Specifically look at the non-accumulated plots and desribe the trends for how long each operation takes as a function of how many elements have already been inserted in the list.
A:The time taken for arithmetic grow list increases as the size of the array grows, the geometric grow list stays constant except for when size is doubled, the java grow list is even more efficient and stays almost constant the wholet ime.

Q: When are there spikes in the per operation runtime graphs for each of the implementations? Do these make sense to you? Hint: some of these should and others might not. Empirical runtime can be quite messy and depends on machine specifics which will be revealed in other subsequent classes like CS61C.
A: The spikes happen whenever the size is doubled. This makes sense for geometric resizing but not arithmetic resizing.

Q: Optional: Try changing the code for GeomGrowList to resize by a different factor. How does this effect the theoretical asymptotic runtime? How does this effect the plotted runtime?
A:

Q: Optional: Try changing the code for ArithGrowList to resize by adding a different fixed number of spots in the array. How does this effect the theoretical asymptotic runtime? How does this effect the plotted runtime?
A: